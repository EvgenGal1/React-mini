webpack.react.message.
Чуть подробнее можно почитать в D:\Про\Курсы-ДЗ\Geekbrains\Frond end разраб\React\[1-8]\Методичкa.pdf


	1.Урок...........................................................................

0. Проверить есть ли на компьютере node.js и npm. (в терминале $$ node -v и $$ npm -v)
1. $$ npm init (npm init -y)
	инициализация. настройка в ком-ой строке, подробнее в package.json.txt. можно настроить позже
	создаёться файл package.json - описание проекта и все установленные зависимости
2. $$ npm install webpack ($$ npm install webpack webpack-cli webpack-dev-server path --seve-dev
	 - установка всего пакета. --seve-dev - среда окружения, должна находится в devDependencies)
	установка webpack - модульный сборщик, упаковка, компиликтовка и организация ресурсов для проекта.
	создаёться папка node_modules - пакеты, установленные вручную, и их зависимости.
3. Создать в корне проекта webpack.config.js - настройка webpack.
	//
	const path = require("path");
	const webpack = require('webpack');
	module.exports = {
		entry: {
			app: './index.js',
		},
		context: path.resolve(__dirname, "static_src"),
		output: {
			path: path.resolve(__dirname, "static", "build"),
			filename: 'app.js',
		},
	};
	//
4. Создать в корне папку static_src и файл index.js в ней.
5. $$ npm install -D webpack-cli
	установка webpack-cli 
6. написать в файл package.json скрипт "build": "webpack" в разделе scripts и сохранить.
	удалить "test": "echo ...
7. $$  npm run build
	Появляеться static/build/app.js. Содержимое файла app.js автоматически минимизируется.
8. $$ npm install webpack-dev-server 
	установка webpack-dev server - статический сервер, раздача содержимого проекта
9. Создадим в корне файл index.html
	//
	<!DOCTYPE html>
	<html lang="ru">
	<head>
		<meta charset="UTF-8">
		<title>React</title>
	</head>
	<body>
	<h1>Курс по ReactJS</h1>
	</body>
	</html>
	//
	Подключим app.js в index.html.
	//
	<script src="/static/build/app.js"></script>
	//
	теперь webpack-dev-server будет отслеживать любые изменения в файлах и на лету пересобирать приложение
10. Чтобы запускать сборку и сервер было проще, можно прописать соответствующие скрипты в package.json.
	//
	"scripts": {
		"start": "webpack --mode development",
		"server": "webpack-dev-server"
	},
	//
	$$ npm run start
	$$ npm run server
	При таком запуске сборки обратите внимание, что теперь app.js получается не минимизированным, 
	так как в скрипте start указан ключ --mode development
11. Импорт JS-файлов друг в друга 
	Создадим новый файл: static_src/script.js
	пропишем:
	//
	export function script() {
		console.log('Это файл script.js');
	}
	//
	в static_src/index.js пропишем:
	//
	import { script } from './script';
	script();
	console.log('А это index.js');
	//
	Таким образом, начиная сборку с entry, указанного в webpack.config.js, 
	webpack следует импортам и собирает все файлы в один единственный app.js.
12. Babel - loader, преобразуют исходный код модулей, заменяет весь новый код на старый, 
	эквивалент для старых браузеров.
	$$ npm install @babel/cli @babel/core @babel/preset-env babel-loader
	настройки webpack.config.js
	//
	module.exports = {
		module: {
			rules: [
				{
						test: /\.(js|jsx)$/,
						include: path.resolve(__dirname, "static_src"),
						loader: 'babel-loader',
						exclude: /node_modules/,
						options: {
							presets: ['@babel/env'],
						}
				},
			],
		},
	}
	//
12.1 Почему то в методичке нет добавление файла .babelrc
	//
	{
		"presets": [
			"@babel/preset-env"
		]
	}
	//
13. React.js — это фреймворк для создания интерфейсов. работает по принципу реактивного программирования, 
 	 то есть позволяет создавать динамические страницы с возможностью обновлений состояний
	установка react
	$$ npm install react react-dom
13.1  Простейшее приложение на React
	в файле index.js напишем простейший код на React
	//
	import React from 'react';
	import ReactDOM from 'react-dom';
	const element = React.createElement(
		'h1',
		{ className: "element" },
		'Кажется, мы подключили React',
	);

	ReactDOM.render(
		element,
		document.getElementById('root'),
	);
	//
	Здесь создается элемент <h1 class="element">. Кажется, мы подключили React</h1>, 
	который потом вставляется в элемент с id="root". Добавим такой элемент в index.html.
	//
	<div id="root"></div>
	//
	Запускаем npm run start
14. JSX - синтаксический сахар для функции React.createElement(component, props, ...children). 
	 Это позволяет писать верстку в html-формате внутри JS-файлов.
	заменяем на
	//
	const element = <h1 className="element">Кажется, мы подключили React</h1>;
	//
15. Чтоб не получить ошибку: ERROR in ./index.js Module build failed(ошибка сборки модуля)..., 
	 изза того что JavaScript не знает синтаксиса html, установим пресет для React, чтобы с помошью babel смогли переделать JSX во что-то понятное обычному JavaScript.
	$$ npm install @babel/preset-react
	добавить в webpack.config.js
	//
	module: {
			rules: [
				{
						query: {
						presets: ['@babel/env', '@babel/react'],
						}
				},
			],
		},
	}
	//
	так не сработало.
	рабочий
	//
	options: {
          presets: ["@babel/env", "@babel/react"],
      		}
	//
16. Тип элемента со строчной буквы - встроенный компонент(<div> или <span>), 
	 передается в виде строки 'div' или 'span' в функцию React.createElement. 
	 Типы с прописной буквы(<Foo />), компилируются как React.createElement(Foo), ссылаются на компонент, 
	 определенный или импортированный в вашем JavaScript-файле. Пример на основе функциональных компонентов.
17. Функциональные компоненты позволяют отделить верстку от содержимого. 
	 В отличие от обычных элементов, которые объявляются как переменные, 
	 функциональные компоненты нужно объявлять в виде функций. static_src/index.js:
	//
	const content = 'Кажется, мы всё ещё подключаем React';
	const Component = (props) => <h1 className="element">{props.content}</h1>;
	ReactDOM.render(
		<Component content={ content } />,
		document.getElementById('root_2'),
	);
	//
	Передаём текст в качестве аргумента, что позволит переиспользовать функциональный компонент 
	(определяется с большой буквы). Вызывается с помощью синтаксиса JSX, а переменные, которые передаются в него, 
	попадают в словарь props.
18. Реализация, компонентов сообщений в рамках мессенджера.
	static_src/index.js:
	//
	let messages = ['Привет', 'Как дела?'];
	const MessageComponent = (props) => <div>{props.text}</div>;
	const MessageField = (props) => {
		return props.messages.map(message => <MessageComponent text={ message } />);
	};
	ReactDOM.render(
		<MessageField messages={ messages } />,
		document.getElementById('root'),
	);
	//
19. Переименуем файл index.js в index.jsx. Впоследствии будем ко всем файлам, использующим синтаксис JSX, 
	 применять это расширение.
20. Перед заливкой удалять (?dist?) node_modules(исполнительные файлы тех модулей которые мы устанавливаем).
	возвращаем исполн. файлы после залявки (равнозначно install - i)
	$$  npm i

	в webpack.config.js не помню от куда взялся в output:{ вот это - publicPath: "/static/build/"

	2.Урок.................................................................................

1. Чаще всего используют React-компоненты(а не функциональные) на основе классов. 
	Они могут верстать, есть свой жизненный цикл, в который можно «вшивать» собственную логику. 
	State(состояние) — перемен. класса комп-та, влияют на поведение компонента и его отрисовку. 
	Из-pf большого кол-ва компонентов, React передает переменные, от верхнего компон. к нижнему, 
	но не наоборот. React-компоненты со своим жизненным циклом, состоянием (state) и 
	строго иерархическим взаимодействием — это основа фреймворка React. 
2. Пишем простейший ReactComponent. В пути будут лежать все наши компоненты.  
	В классе компонента обязательно должна быть реализована функция render(). 
	То, что возвращает эта функция, как раз и выводится на экран.
	Создаём /static_src/components/App.jsx
	//
	import React from 'react' ;
	export default class App extends React. Component {
		render () {
			return (
				<h1> Наш первый React-компонент </h1>
			)
		}
	}
	//
	добавляем его в index.jsx
	//
	import App from './components/App.jsx' ;
		ReactDOM. render (
		<App /> ,
		document.getElementById('root'),
	);	
	//
3. Добавим state в компонент App и будем использовать его в рендере компонента: 
	static_src/components/App.jsx, после .... React.Component {
	//
	state = {
		text : 'Наш первый React-компонент'
	} ;
	//
	//
	<h1>{this.state.text}</h1>
	//
4. $$ npm install @babel/plugin-proposal-class-propertiesnpm install @babel/plugin-proposal-class-properties
	Ещё один babel, для обработки синтаксиса, пока не доступтного JS
	Пропишем его и в webpack.config.json
	//
	plugins : [
		[
			"@babel/plugin-proposal-class-properties" ,
			{
			"loose" : true
			}
		]
	]
	//
5. обновим state через секунду после первой отрисовки компонента. 
	Делается это вызовом функции this.setState()
	В static_src/components/App.jsx в render(){ перед return
	setTimeout(() => this.setState({ 'text': 'Обновленный React-компонент' }), 1000);
6. Теперь, при запуске сервера и открытие в браузере приложения, тект, через секунду изменится.
	Обновление state влечет за собой повторный вызов функции render(), и компонент перерисовывается.
	На самом деле вызывается не только функция render() , но об этом позже.
7. Хуки — это функции, с помощью которых вы можете «подцепиться» к состоянию и методам жизненяного цикла React из функциональных компонентов. 
	Хуки не работают внутри классов — они дают вам возможность использовать React без классов.
	Подоробнее https://ru.reactjs.org/docs/hooks-intro.html
	Функциональные компоненты можно наделить состоянием, с помощью хуков. Жизненный цикл компонента представляет собой вызов ряда методов компонента перед определенными событиями или после них: componentWillMount - функция вызывается перед тем, как компонент будет отрисован, 
	render - ф-я отрисовывает компонент и вызывается при каждом последующем обновлении state,
	componentDidMount - функция вызывается сразу после первой отрисовки компонента на странице,
	componentDidUpdate - функция вызывается при обновлениях после перерисовки
	componentWillUnmoun - функция, которая вызывается при далении компонента со страницы.
	В static_src/components/App.jsx
	//
	componentWillMount() {
		console.log('componentWillMount');
	}
	componentDidMount () {
		console.log('componentDidMount');
		setTimeout(() => this.setState({'text':'Обновленный React-компонент'}),
	1000);
	}
	componentDidUpdate() {
		console.log('componentDidUpdate');
	}
	//
	state переносим из render в componentDidMount
7.1 Браузер. Консоль разработчика.
	//
	componentWillMount
	render
	componentDidMount
	[WDS] Live Reloading enabled.
	render
	componentDidUpdate
	//
	Второй вызов render и последующий componentDidUpdate были осуществлены после обновления state через секунду после отрисовки компонента.
8. Вложенность компонентов, props и propTypes
	Создаём static_src/components/Child.jsx с таким же жизненным циклом.
	//
	import React from 'react' ;
	export default class Child extends React. Component {
		componentWillMount() {
			console.log('Child componentWillMount');
		}
		componentDidMount() {
			console.log('Child componentDidMount');
		}
		componentDidUpdate() {
			console.log('Child componentDidUpdate');
		}
		render() {
			console.log('Child render');
			return(
				<h1>Это компонент Child</h1>
			)
		}
	}
	//
9.	Вложим Child.jsx в App.jsx. 
	Передадим счетчик в качестве props, добавим кнопку, для увеличения счетчика на единицу.
	В static_src/components/App.jsx
	//
	import Child from './Child.jsx';
	state = {
		text: 'Наш первый React-компонент' ,
		counter: 0,
	};
	.....
	handleClick = () => {
		this.setState ({ 'counter': this.state.counter + 1 })
	};
	render () {
		console.log ('render') ;
		return (
			<div>
				<h1>{this.state.text}</h1>
				<Child counter={ this.state.counter }/>
				<button onClick = { this.handleClick }>+1</button>
			</div>
		)
	}
	//
	handleClick - стрелочная ф-я, благодаря этому используется контекст компонента App для переменной this внутри нее. Обычная ф-я внутри компонента, «теряется» контекст. Его нужно будет привязать в конструкторе командой this.handleClick.bind(this).
	Компонент Child получает counter в качестве props, который будет увеличиваться на 1 при каждом нажатии на кнопку. Обернули все в <div>, так как render возвращает либо один элемент, либо массив элементов.
10. Можно импортировать jsx-файлы без расширения - import Child from './Child'. Добавим в webpack.config.js следующую настройку:
	//
	const webpack = require( 'webpack' ) ;
	module.exports = {
		.....
		resolve: {
			modules: [`${__dirname} /static_src`, 'node_modules'],
			extensions: ['.js', '.jsx'],
		},
	};
	//
11. Получим переданный props :
	static_src/components/Child.jsx
	//
	return (
			<h1>Это компонент Child, counter: { this.props.counter}</h1>
		)
	//
11.1 Браузер. Консоль разработчика.
	//
	componentWillMount
	render
	Child	componentWillMount
	Child render
	Child componentDidMount
	componentDidMount
	[WDS] Live Reloading enabled
	//
	Внимание на последовательность вызова функций в родительском (App.jsx) и дочернем (Child.jsx) компонентах.
	Нажмём кнопку +1:
	Браузер. Консоль разработчика.
	//
	componentWillMount
	render
	Child	componentWillMount
	Child render
	Child componentDidMount
	componentDidMount
	[WDS] Live Reloading enabled
	render
	Child render
	Child componentDidUpdate
	componentDidUpdate
	//
	Внимание на последовательность вызова функций.
	В данном случае дочерний компонент был перерисован, так как перерендерился родительский в результате изменения state.
	Обновление React-компонента происходит не только при обновлении state, но и при изменении props. В целом, набор state и props определяет состояние компонента, изменение которого приводит к его перерисовке. Чтобы принудительно обновить компонент, то можно воспользоваться функцией forceUpdate().
12. Для контроля типов передаваемых в компонент propsов можно использовать стороннюю библиотеку
PropTypes.
	$$ npm install prop-types
	В static_src/components/Child.JSX
	//
	import PropTypes from 'prop-types';
	export default class Child extends React.Component {
		static propTypes = {
			counter: PropTypes.number ,
		};
	.....
	}	
	//
12.1 НЕПОНЯТНО!!!
	если counter окажется строкой, увидим ошибку в панели разработчика
	isRequired означает, что counter обязательно должен быть передан в Child . Если мы забудем
передать его, то опять увидим ошибку:
	см. pdf - D:\Про\Курсы-ДЗ\Geekbrains\Frond end разраб\React\2. компоненты(Mes,Mese,ChaIn)\Методичка 2.pdf 
	Но если какой-то props не обязательно передавать в компонент, то можно задать значение по
умолчанию ( isRequired в таком случае нужно убрать):
	см. pdf - D:\Про\Курсы-ДЗ\Geekbrains\Frond end разраб\React\2. компоненты(Mes,Mese,ChaIn)\Методичка 2.pdf
	static_src/components/Child.jsx
	//
	import React from 'react' ;
	import PropTypes from 'prop-types' ;
	export default class Child extends React. Component {
		static propTypes = {
			counter : PropTypes. number ,
		} ;
		defaultProps = {
			counter : 0 ,
		};
	...
	}
	//
13. Начало разработки мессенджера
	Разработаем интерфейс для мессенджера. Реализуем возможность отправлять сообщение с одним и тем же текстом по нажатию кнопки.
	Необходим компонент сообщения static_src/components/Message.jsx:
	//
	import React from 'react';
	import PropTypes from 'prop-types';
	export default class Message extends React.Component {
		static propTypes = {
			text: PropTypes.string.isRequired,
		};
		render() {
			return <div> {this.props.text} </div>
		}
	}
	//
13.1 Еще нужен компонент, в котором будет кнопка отправки сообщения, а также сами сообщения в качестве дочерних компонентов.
	static_src/components/MessageField.jsx
	//
	import React from 'react' ;
	import Message from './Message' ;
	export default class MessageField extends React. Component {
		state = {
			messages : [ "Привет!" , "Как дела?" ]
		} ;
		handleClick = () => {
			this.setState ({ messages: [ ... this.state.messages, 'Нормально' ] }) ;
		} ;
		render () {
			const messageElements = this . state . messages . map ((text , index) => (
				<Message key = { index } text = { text } /> )) ;
		return <div>
			{ messageElements }
			<button onClick = { this.handleClick } > Отправить сообщение </button>
			</div>
		}
	}
	//
13.2 В state MessageField храним тексты сообщений..............