webpack.react.message.
Чуть подробнее можно почитать в D:\Про\Курсы-ДЗ\Geekbrains\Frond end разраб\React\[1-8]\Методичкa.pdf


	1.Урок...........................................................................

0. Проверить есть ли на компьютере node.js и npm. (в терминале $$ node -v и $$ npm -v)
1. $$ npm init (npm init -y)
	инициализация. настройка в ком-ой строке, подробнее в package.json.txt. можно настроить позже
	создаёться файл package.json - описание проекта и все установленные зависимости
2. $$ npm install webpack ($$ npm install webpack webpack-cli webpack-dev-server path --seve-dev
	 - установка всего пакета. --seve-dev - среда окружения, должна находится в devDependencies)
	установка webpack - модульный сборщик, упаковка, компиликтовка и организация ресурсов для проекта.
	создаёться папка node_modules - пакеты, установленные вручную, и их зависимости.
3. Создать в корне проекта webpack.config.js - настройка webpack.
	//
	const path = require("path");
	const webpack = require('webpack');
	module.exports = {
		entry: {
			app: './index.js',
		},
		context: path.resolve(__dirname, "static_src"),
		output: {
			path: path.resolve(__dirname, "static", "build"),
			filename: 'app.js',
		},
	};
	//
4. Создать в корне папку static_src и файл index.js в ней.
5. $$ npm install -D webpack-cli
	установка webpack-cli 
6. написать в файл package.json скрипт "build": "webpack" в разделе scripts и сохранить.
	удалить "test": "echo ...
7. $$  npm run build
	Появляеться static/build/app.js. Содержимое файла app.js автоматически минимизируется.
8. $$ npm install webpack-dev-server 
	установка webpack-dev server - статический сервер, раздача содержимого проекта
9. Создадим в корне файл index.html
	//
	<!DOCTYPE html>
	<html lang="ru">
	<head>
		<meta charset="UTF-8">
		<title>React</title>
	</head>
	<body>
	<h1>Курс по ReactJS</h1>
	</body>
	</html>
	//
	Подключим app.js в index.html.
	//
	<script src="/static/build/app.js"></script>
	//
	теперь webpack-dev-server будет отслеживать любые изменения в файлах и на лету пересобирать приложение
10. Чтобы запускать сборку и сервер было проще, можно прописать соответствующие скрипты в package.json.
	//
	"scripts": {
		"start": "webpack --mode development",
		"server": "webpack-dev-server"
	},
	//
	$$ npm run start
	$$ npm run server
	При таком запуске сборки обратите внимание, что теперь app.js получается не минимизированным, 
	так как в скрипте start указан ключ --mode development
11. Импорт JS-файлов друг в друга 
	Создадим новый файл: static_src/script.js
	пропишем:
	//
	export function script() {
		console.log('Это файл script.js');
	}
	//
	в static_src/index.js пропишем:
	//
	import { script } from './script';
	script();
	console.log('А это index.js');
	//
	Таким образом, начиная сборку с entry, указанного в webpack.config.js, 
	webpack следует импортам и собирает все файлы в один единственный app.js.
12. Babel - loader, преобразуют исходный код модулей, заменяет весь новый код на старый, 
	эквивалент для старых браузеров.
	$$ npm install @babel/cli @babel/core @babel/preset-env babel-loader
	настройки webpack.config.js
	//
	module.exports = {
		module: {
			rules: [
				{
						test: /\.(js|jsx)$/,
						include: path.resolve(__dirname, "static_src"),
						loader: 'babel-loader',
						exclude: /node_modules/,
						options: {
							presets: ['@babel/env'],
						}
				},
			],
		},
	}
	//
12.1 Почему то в методичке нет добавление файла .babelrc
	//
	{
		"presets": [
			"@babel/preset-env"
		]
	}
	//
13. React.js — это фреймворк для создания интерфейсов. работает по принципу реактивного программирования, 
 	 то есть позволяет создавать динамические страницы с возможностью обновлений состояний
	установка react
	$$ npm install react react-dom
13.1  Простейшее приложение на React
	в файле index.js напишем простейший код на React
	//
	import React from 'react';
	import ReactDOM from 'react-dom';
	const element = React.createElement(
		'h1',
		{ className: "element" },
		'Кажется, мы подключили React',
	);

	ReactDOM.render(
		element,
		document.getElementById('root'),
	);
	//
	Здесь создается элемент <h1 class="element">. Кажется, мы подключили React</h1>, 
	который потом вставляется в элемент с id="root". Добавим такой элемент в index.html.
	//
	<div id="root"></div>
	//
	Запускаем npm run start
14. JSX - синтаксический сахар для функции React.createElement(component, props, ...children). 
	 Это позволяет писать верстку в html-формате внутри JS-файлов.
	заменяем на
	//
	const element = <h1 className="element">Кажется, мы подключили React</h1>;
	//
15. Чтоб не получить ошибку: ERROR in ./index.js Module build failed(ошибка сборки модуля)..., 
	 изза того что JavaScript не знает синтаксиса html, установим пресет для React, чтобы с помошью babel смогли переделать JSX во что-то понятное обычному JavaScript.
	$$ npm install @babel/preset-react
	добавить в webpack.config.js
	//
	module: {
			rules: [
				{
						query: {
						presets: ['@babel/env', '@babel/react'],
						}
				},
			],
		},
	}
	//
	так не сработало.
	рабочий
	//
	options: {
          presets: ["@babel/env", "@babel/react"],
      		}
	//
16. Тип элемента со строчной буквы - встроенный компонент(<div> или <span>), 
	 передается в виде строки 'div' или 'span' в функцию React.createElement. 
	 Типы с прописной буквы(<Foo />), компилируются как React.createElement(Foo), ссылаются на компонент, 
	 определенный или импортированный в вашем JavaScript-файле. Пример на основе функциональных компонентов.
17. Функциональные компоненты позволяют отделить верстку от содержимого. 
	 В отличие от обычных элементов, которые объявляются как переменные, 
	 функциональные компоненты нужно объявлять в виде функций. static_src/index.js:
	//
	const content = 'Кажется, мы всё ещё подключаем React';
	const Component = (props) => <h1 className="element">{props.content}</h1>;
	ReactDOM.render(
		<Component content={ content } />,
		document.getElementById('root_2'),
	);
	//
	Передаём текст в качестве аргумента, что позволит переиспользовать функциональный компонент 
	(определяется с большой буквы). Вызывается с помощью синтаксиса JSX, а переменные, которые передаются в него, 
	попадают в словарь props.
18. Реализация, компонентов сообщений в рамках мессенджера.
	static_src/index.js:
	//
	let messages = ['Привет', 'Как дела?'];
	const MessageComponent = (props) => <div>{props.text}</div>;
	const MessageField = (props) => {
		return props.messages.map(message => <MessageComponent text={ message } />);
	};
	ReactDOM.render(
		<MessageField messages={ messages } />,
		document.getElementById('root'),
	);
	//
19. Переименуем файл index.js в index.jsx. Впоследствии будем ко всем файлам, использующим синтаксис JSX, 
	 применять это расширение.
20. Перед заливкой удалять (?dist?) node_modules(исполнительные файлы тех модулей которые мы устанавливаем).
	возвращаем исполн. файлы после залявки (равнозначно install - i)
	$$  npm i

	в webpack.config.js не помню от куда взялся в output:{ вот это - publicPath: "/static/build/"

	2.Урок.................................................................................

1. Чаще всего используют React-компоненты(а не функциональные) на основе классов. 
	Они могут верстать, есть свой жизненный цикл, в который можно «вшивать» собственную логику. 
	State(состояние) — перемен. класса комп-та, влияют на поведение компонента и его отрисовку. 
	Из-pf большого кол-ва компонентов, React передает переменные, от верхнего компон. к нижнему, 
	но не наоборот. React-компоненты со своим жизненным циклом, состоянием (state) и 
	строго иерархическим взаимодействием — это основа фреймворка React. 
2. Пишем простейший ReactComponent. В пути будут лежать все наши компоненты.  
	В классе компонента обязательно должна быть реализована функция render(). 
	То, что возвращает эта функция, как раз и выводится на экран.
	Создаём /static_src/components/App.jsx
	//
	import React from 'react' ;
	export default class App extends React. Component {
		render () {
			return (
				<h1> Наш первый React-компонент </h1>
			)
		}
	}
	//
	добавляем его в index.jsx
	//
	import App from './components/App.jsx' ;
		ReactDOM. render (
		<App /> ,
		document.getElementById('root'),
	);	
	//
3. Добавим state в компонент App и будем использовать его в рендере компонента: 
	static_src/components/App.jsx, после .... React.Component {
	//
	state = {
		text : 'Наш первый React-компонент'
	} ;
	//
	//
	<h1>{this.state.text}</h1>
	//
4. $$ npm install @babel/plugin-proposal-class-propertiesnpm install @babel/plugin-proposal-class-properties
	Ещё один babel, для обработки синтаксиса, пока не доступтного JS
	Пропишем его и в webpack.config.json
	//
	plugins : [
		[
			"@babel/plugin-proposal-class-properties" ,
			{
			"loose" : true
			}
		]
	]
	//
5. обновим state через секунду после первой отрисовки компонента. 
	Делается это вызовом функции this.setState()
	В static_src/components/App.jsx в render(){ перед return
	setTimeout(() => this.setState({ 'text': 'Обновленный React-компонент' }), 1000);
6. Теперь, при запуске сервера и открытие в браузере приложения, тект, через секунду изменится.
	Обновление state влечет за собой повторный вызов функции render(), и компонент перерисовывается. 
	На самом деле вызывается не только функция render() , но об этом позже.
7. Хуки — это функции, с помощью которых вы можете «подцепиться» к состоянию и 
	методам жизненного цикла React из функциональных компонентов. 
	Хуки не работают внутри классов — они дают вам возможность использовать React без классов.
	Подоробнее https://ru.reactjs.org/docs/hooks-intro.html
	Функциональные компоненты можно наделить состоянием, с помощью хуков.
	Жизненный цикл компонента представляет собой вызов ряда методов компонента перед определенными событиями или после них: 
	componentWillMount - функция вызывается перед тем, как компонент будет отрисован,
	render - ф-я отрисовывает компонент и вызывается при каждом последующем обновлении state, 
	componentDidMount - функция вызывается сразу после первой отрисовки компонента на странице,
	componentDidUpdate - функция вызывается при обновлениях после перерисовки
	componentWillUnmoun - функция, которая вызывается при удалении компонента со страницы.
	В static_src/components/App.jsx
	//
	componentWillMount() {
		console.log('componentWillMount');
	}
	componentDidMount () {
		console.log('componentDidMount');
		setTimeout(() => this.setState({'text':'Обновленный React-компонент'}),
	1000);
	}
	componentDidUpdate() {
		console.log('componentDidUpdate');
	}
	//
	state переносим из render в componentDidMount
8. Вложенность компонентов, props и propTypes
	создаём static_src/components/Child.jsx
	//
	import React from 'react' ;
	export default class Child extends React. Component {
		componentWillMount() {
			console.log('Child componentWillMount');
		}
		componentDidMount() {
			console.log('Child componentDidMount');
		}
		componentDidUpdate() {
			console.log('Child componentDidUpdate');
		}
		render() {
			console.log('Child render');
			return(
				<h1>Это компонент Child</h1>
			)
		}
	}
	//
9.	Вложим Child.jsx в App.jsx. Передадим счетчик в качестве props, добавим кнопку, для увеличения счетчика на единицу.
	В static_src/components/App.jsx